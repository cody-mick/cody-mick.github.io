<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../css/styles.css" />
    <title>Week 7 | WDD 330</title>
  </head>

  <body>
    <main>
      <div class="notes-page">
        <h1>Week 07</h1>
        <div>
          <a href="hiking-complete.html">Team Activity</a>
        </div>
        <div class="questions">
          <h2>Questions:</h2>
          <ul></ul>
        </div>
        <div class="notes">
          <h3>Ch. 11 - Further Functions</h3>
          <p>
            Functions are <strong>first-class objects</strong>. Because of this,
            it means that functions can have properties and methods.
          </p>
          <p>
            The call() method can be used to set the value of this inside a
            function to an object that is provided as the first argument.
          </p>
          <p>
            If a function doesn't refer to an object as <em>this</em> in its
            body, it can still be called using the call() method, but you need
            to provide <em>null</em> as its first argument.
          </p>
          <p>
            An <strong>Immediately Invoked Function Expression (IIFE)</strong> -
            pronounced "iffy" - is an anonymous function that, as the name
            suggests, is invoked as soon as it's defined. That would look like
            this.
          </p>
          <pre>
            <code>
              (function() {
                const temp = "World";
                console.log(`Hello ${temp}`);
              })(); 
              << 'Hello World'
            </code>
          </pre>
          <p>
            You declare the function inside parentheses and then call the
            function immediately afterwards by placing parentheses at the end of
            the declaration.
          </p>
          <p>
            IIFEs are a useful way of performing a task while keeping any
            variables wrapped up within the scope of the function.
          </p>
          <p>Functions can define and rewrite themselves.</p>
          <h4>Callbacks</h4>
          <p>
            Callbacks are functions passed to other functions as arguments and
            then invoked inside the function they are passed to.
          </p>
          <p>
            Callbacks can be used to facilitate event-driven asynchronous
            programming. JavaScript is a single-threaded environment, which
            means that only ever one piece of code will ever be processed at a
            time. This means that there can be blockers. But non-blocking
            techniques can be used to endure that the program continues to run.
            Instead of waiting for an even to occur, a callback can be created
            that's invoked when the event happens. This means that the code is
            able to run out of order or, <em>asynchronously</em>.
          </p>
          <h5>Callback Hell</h5>
          <p>
            The increase in the use of asynchronous programming in JavaScript
            has meant that more and more callbacks are being used. This can
            result in messy and confusing "spaghetti code". This is when more
            than one callback is used in the same function, resulting in a large
            number of nested blocks that are difficult to comprehend.
          </p>
          <h4>Promises</h4>
          <p>
            A promise represents the future result of an asynchronous operation.
            Promises don't do anything that can't already be achieved using
            callbacks, but they help simplify the process, and avoid the
            convoluted code that can result from using multiple callbacks.
          </p>
          <h4>The Promise Life Cycle</h4>
          <div>
            When a promise is created, it calls and asynchronous operation and
            is then said the be pending. It remains in this state while the
            operation is taking place. At this stage, the promise is said to be
            unsettled. Once the operation has completed , the promise is said to
            have been settled. A settled promise can result in 2 different
            outcomes:
            <ul>
              <li>
                Resolved - The asynchronous operation was completed
                successfully.
              </li>
              <li>
                Rejected - The asynchronous operation didn't work as expected,
                wasn't successfully completed or resulted in an error.
              </li>
            </ul>
            Both of these outcomes will return any relevant data, and you can
            take the appropriate action based on the outcome of the promise.
            Summarized Promise Life Cycle:
            <ol>
              <li>
                <strong>Pending</strong> - Promise is created and calls the
                asynchronous operation.
              </li>
              <li>
                <strong>Unsettled</strong> - Promise is still pending and the
                operation is still taking place.
              </li>
              <li>
                <strong>Settled</strong> - The operation has finished and the
                result will be one of these 2 options:
                <ul>
                  <li>
                    <strong>Resolved</strong> - The asynchronous operation was
                    completed successfully.
                  </li>
                  <li>
                    <strong>Rejected</strong> - The asynchronous operation
                    didn't work as expected, wasn't successfully completed or
                    resulted in an error.
                  </li>
                </ul>
              </li>
            </ol>
          </div>
          <p>The general layout of a promise is usually as follows:</p>
          <pre>
            <code>
              const promise = new Promise((resolve, reject) => { 
                // initialization code here
                if (success) {
                  resolve(value);
                } else {
                  reject(error);
                }
              });
            </code>
          </pre>
          <h4>Dealing with a Settled Promise</h4>
          <div>
            Once a promise has been settled, the then() method can be useful to
            deal with the outcome. then() accepts 2 arguments:
            <ol>
              <li>
                Fulfillment Function - this is called when the promise is
                resolved. Any data returned from the resolve() function will be
                passed along to this function.
              </li>
              <li>
                Rejection Function - this is called when the promise is
                rejected. The rejection function receives any data returned from
                the reject() function.
              </li>
            </ol>
          </div>
          <h4>Chaining Multiple Promises</h4>
          <p>
            Promises really come into their own when multiple asynchronous tasks
            are required to be carried out one after the other. You can chain
            promises together using then() methods. Like so:
          </p>
          <pre>
            <code>
              login(userName)
              .then(user => getPlayerInfo(user.id))
              .then(info => loadGame(info))
              .catch( throw error)
            </code>
          </pre>
          <h4>Async Functions</h4>
          <p>
            These functions are preceeded by the <em>async</em> keyword, and
            allow you to write asynchronous code as if it was synchronous. This
            is achieved by using the <strong>await</strong> operator before an
            asynchronous function. This will wrap the return value of the
            function in a promise that can then be assigned to a variable. The
            next line of code is not executed until the promise is resolved.
          </p>
          <p>Here is our login function written as an async function:</p>
          <pre>
            <code>
              async function loadGame(userName) {
                try { 
                  const user = await
                  login(userName);
                  const info = await getPlayerInfo(user.id);
                } catch (error) {
                  throw error;
                }
              }
            </code>
          </pre>
          <h4>Functions That Return Functions</h4>
          <pre>
            <code>
              function returnHello() {
                console.log('returnHello() called');
                return function() {
                  console.log('Hello World!');
                }
              }
            </code>
          </pre>
          <h4>Closures</h4>
          <p>
            A closure is formed when a function returns another function that
            then maintains access to any variable created in the original
            function's scope.
          </p>
          <p>Here is an example of a counter function using a closure:</p>
          <pre>
            <code>
              function counter(start) {
                let i = start;
                return function() {
                  return i++;
                }
              }
            </code>
          </pre>
          <p>
            We would then assign this function to a variable, and that is how we
            would maintain access to the inner variables.
          </p>
          <code> const count = counter(1); </code>
          <p>Calling this function will then initialize the count.</p>
          <code> count(); output: 1 </code>
          <code> count(); output: 2 </code>
          <h4>Generators</h4>
          <p>
            Generators are special functions used to produce iterators that
            maintain the state of a value. To define a generator function, an
            asterisk (*) is placed after the function declaration.
          </p>
          <code>
            function* exampleGenerator() { // code for the generator goes here.
            }
          </code>
          <p>
            Calling a generator function doesn't actually run any of the code in
            the function. It returns a Generator object that can be used to
            create an iterator that implements a next() method that returns a
            value every time the next() method is called.
          </p>
          <pre>
            <code>
              function* fibonacci(a,b) {
                let [prev, current] = [a,b]; 
                while(true) {
                  [prev, current] = [current, prev + current];
                  yield current;
                }
              }
            </code>
          </pre>
          <p>
            Because this is a generator, it will only run when the next() method
            is called on it. If we assign this function to a variable, the
            variable will hold the value and store it for use. We could then
            call next() on the variable and execute the code to our liking. Like
            so:
          </p>
          <pre>
            <code>
              const fib = fibonacci(1,1); 
              fib.next(); output: 2 
              fib.next(); output: 3 
              fib.next(); output: 5
            </code>
          </pre>
          <p>
            You could also iterate over the generator and break the loop once a
            desired value is reached.
          </p>
          <pre>
            <code>
              for (n of fibonacci) { 
              // stop the sequence after it reaches 100 if
                (n > 10) break; console.log(n); 
              } 
              output: 8, 13, 21, 34, 55, 89
            </code>
          </pre>
          <p>
            The generator will maintain it's value from the last used instance
            of the next() method. It will maintain it's state through the life
            of the program.
          </p>
          <h4>Pure Functions</h4>
          <div>
            A key aspect of functional programming is its use of pure functions.
            A pure function is a function that adheres to the following rules:
            <ol>
              <li>
                The return value of a pure function should only depend on the
                values provided as arguments. It doesn't rely on values from
                somewhere else in the program
              </li>
              <li>
                There are no side-effects. A pure function doesn't change any
                values or data elsewhere in the program. It only makes
                non-destructive data transformations and returns new values,
                rather than altering any of the underlying data
              </li>
              <li>
                Referential transparency. Given the same arguments, a pure
                function will always return the same result.
              </li>
            </ol>
            In order to follow these rules, any pure function must have:
            <ul>
              <li>
                At least one argument; otherwise the return value must depend on
                something other than the arguments of the function, breaking the
                first rule.
              </li>
              <li>
                A return value; otherwise there's no point in the function
                (unless it has changed something else in the program - in which
                case, it's broken the 'no side-effects' rule.
              </li>
            </ul>
          </div>
          <h4>High-Order Functions</h4>
          <p>
            Higher-order functions are functions that accept another unction as
            an argument, or return another function as a result, or both.
          </p>
          <h4>Currying</h4>
          <p>
            Currying is a process that involves the partial application of
            functions. A function is said to be curried when not all arguments
            have been supplied to the function, so it returns another function
            that retains the arguments already provided, and expects the
            remaining arguments that were omitted when the original function was
            called. A final result is only returned once all the expected
            arguments have eventually been provided.
          </p>
          <p>
            All curried functions are higher-order functions, but not all
            higher-order functions are curried.
          </p>
          <p>Basic order of a curry:</p>
          <pre>
            <code>
              function curry(func,...oldArgs) {
                return function(...newArgs) {
                  const allArgs = [...oldArgs,...newArgs];
                  return func(...allArgs);
                }
              }
            </code>
          </pre>
        </div>
      </div>
    </main>
    <footer>Cody Mickelsen | WDD 330 | BYU-Idaho | Fall 2021</footer>
  </body>
</html>
