<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../css/styles.css" />
    <title>Week 7 | WDD 330</title>
  </head>
  <body>
    <main>
      <div class="notes-page">
        <h1>Week 07</h1>
        <div>
          <a href="hiking-complete.html">Team Activity</a>
        </div>
        <div class="questions">
          <h2>Questions:</h2>
          <ul>
          </ul>
        </div>
        <div class="notes">
          <h3>Ch. 11 - Further Functions</h3>
          <p>Functions are <strong>first-class objects</strong>. Because of this, it means that functions can have properties and methods.</p>
          <p>The call() method can be used to set the value of this inside a function to an object that is provided as the first argument.</p>
          <p>If a function doesn't refer to an object as <em>this</em> in its body, it can still be called using the call() method, but you need to provide <em>null</em> as its first argument.</p>
          <p>An <strong>Immediately Invoked Function Expression (IIFE)</strong> - pronounced "iffy" - is an anonymous function that, as the name suggests, is invoked as soon as it's defined. That would look like this.</p>
          <code>
            (function(){
              const temp = "World";
              console.log(`Hello ${temp}`);
            })();
            << 'Hello World'
          </code>
          <p>You declare the function inside parentheses and then call the function immediately afterwards by placing parentheses at the end of the declaration.</p>
          <p>IIFEs are a useful way of performing a task while keeping any variables wrapped up within the scope of the function.</p>
          <p>Functions can define and rewrite themselves.</p>
          <h4>Callbacks</h4>
          <p>Callbacks are functions passed to other functions as arguments and then invoked inside the function they are passed to.</p>
          <p>
            Callbacks can be used to facilitate event-driven asynchronous programming. JavaScript is a single-threaded environment, which means that only ever one piece of code will ever be processed at a time.
            This means that there can be blockers. But non-blocking techniques can be used to endure that the program continues to run. Instead of waiting for an even to occur, a callback can be created that's invoked when the event happens.
            This means that the code is able to run out of order or, <em>asynchronously</em>.
          </p>
          <h5>Callback Hell</h5>
          <p>
            The increase in the use of asynchronous programming in JavaScript has meant that more and more callbacks are being used. This can result in messy and confusing "spaghetti code". This is when more than one callback
            is used in the same function, resulting in a large number of nested blocks that are difficult to comprehend.
          </p>
          <h4>Promises</h4>
          <p>
            A promise represents the future result of an asynchronous operation. Promises don't do anything that can't already be achieved using callbacks, but they help simplify the process, and avoid the convoluted code that can result
            from using multiple callbacks.
          </p>
          <h4>The Promise Life Cycle</h4>
          <p>
            When a promise is created, it calls and asynchronous operation and is then said the be pending. It remains in this state while the operation is taking place. At this stage, the promise is said to be unsettled. Once the operation has completed
            , the promise is said to have been settled. A settled promise can result in 2 different outcomes:
            <ul>
              <li>Resolved - The asynchronous operation was completed successfully.</li>
              <li>Rejected - The asynchronous operation didn't work as expected, wasn't successfully completed or resulted in an error.</li>
            </ul>
            Both of these outcomes will return any relevant data, and you can take the appropriate action based on the outcome of the promise.
            Summarized Promise Life Cycle:
            <ol>
              <li><strong>Pending</strong> - Promise is created and calls the asynchronous operation.</li>
              <li><strong>Unsettled</strong> - Promise is still pending and the operation is still taking place.</li>
              <li><strong>Settled</strong> - The operation has finished and the result will be one of these 2 options:
                <ul>
                  <li><strong>Resolved</strong> - The asynchronous operation was completed successfully.</li>
                  <li><strong>Rejected</strong> - The asynchronous operation didn't work as expected, wasn't successfully completed or resulted in an error.</li>
                </ul>
              </li>
            </ol>
          </p>
          <p>
            The general layout of a promise is usually as follows:
          </p>
          <code>
            const promise = new Promise( (resolve, reject) => { // initialization code here if (success) {resolve(value);} else {reject(error);}});
          </code>
          <h4>Dealing with a Settled Promise</h4>
          <p>
            Once a promise has been settled, the then() method can be useful to deal with the outcome. then() accepts 2 arguments:
            <ol>
              <li>Fulfillment Function - this is called when the promise is resolved. Any data returned from the resolve() function will be passed along to this function.</li>
              <li>Rejection Function - this is called when the promise is rejected. The rejection function receives any data returned from the reject() function.</li>
            </ol>
          </p>
          <h4>Chaining Multiple Promises</h4>
          <p>Promises really come into their own when multiple asynchronous tasks are required to be carried out one after the other. You can chain promises together using then() methods. Like so:</p>
          <code>
            login(userName).then(user => getPlayerInfo(user.id)).then(info => loadGame(info)).catch( throw error)
          </code>
          <h4>Async Functions</h4>
          <p>These functions are preceeded by the <em>async</em> keyword, and allow you to write asynchronous code as if it was synchronous. This is achieved by using the <strong>await</strong> operator
          before an asynchronous function. This will wrap the return value of the function in a promise that can then be assigned to a variable. The next line of code is not executed until the promise is resolved.</p>
          <p>Here is our login function written as an async function:</p>
          <code>
            async function loadGame(userName) {
              try {
                const user = await login(userName);
                const info = await getPlayerInfo(user.id);
              }
              catch (error){
                throw error;
              }
            }
          </code>
          <h4>Functions That Return Functions</h4>
          <code>
            function returnHello() {console.log('returnHello() called'); return function(){console.log('Hello World!');}}
          </code>
          <h4>Closures</h4>
          <p>A closure is formed when a function returns another function that then maintains access to any variable created in the original function's scope.</p>
      </div>
    </main>
    <footer>Cody Mickelsen | WDD 330 | BYU-Idaho | Fall 2021</footer>
  </body>
</html>